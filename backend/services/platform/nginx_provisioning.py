"""
Nginx Provisioning Service

Automatically provisions (and deprovisions) Nginx virtual hosts + SSL certificates
for verified custom domains. All shell commands run via asyncio.subprocess so the
event loop is never blocked.

Flow triggered by DomainService.verify_domain() on success:
  1. Write Nginx server block to /etc/nginx/sites-available/<bare-domain>
  2. Symlink into /etc/nginx/sites-enabled/
  3. Test config (`nginx -t`)
  4. Reload Nginx (`systemctl reload nginx`)
  5. Issue SSL via certbot (`certbot --nginx ...`)
     — SSL failure is non-fatal; the site still serves over HTTP.

Flow triggered by DomainService.remove_domain():
  1. Remove symlink and config file
  2. Reload Nginx
"""
import asyncio
import logging
import os
from pathlib import Path

logger = logging.getLogger(__name__)

# ── Constants ─────────────────────────────────────────────────────────────────

SITES_ROOT = "/var/www/sites"
NGINX_AVAILABLE = "/etc/nginx/sites-available"
NGINX_ENABLED = "/etc/nginx/sites-enabled"

# Read from environment so this works across deployments without code changes.
CERTBOT_EMAIL = os.getenv("CERTBOT_EMAIL", "admin@lavish.solutions")

# ── Nginx server block template ───────────────────────────────────────────────

_VHOST_TEMPLATE = """\
# WebMagic custom domain: {bare_domain} → site slug: {slug}
# Auto-generated by NginxProvisioningService – do not edit manually.
server {{
    server_name {server_names};

    root {sites_root}/{slug};
    index index.html;

    location / {{
        try_files $uri $uri/ /index.html;
    }}

    location ~* \\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|webp)$ {{
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}

    location ~* \\.html$ {{
        expires -1;
        add_header Cache-Control "no-store, no-cache, must-revalidate";
    }}

    location ~ /\\. {{ deny all; }}

    listen 80;
}}
"""


# ── Service ───────────────────────────────────────────────────────────────────

class NginxProvisioningService:
    """Provisions / deprovisions Nginx vhosts and SSL certs for custom domains."""

    @staticmethod
    async def provision(domain: str, slug: str) -> dict:
        """
        Provision Nginx vhost + SSL for a verified domain.

        Args:
            domain: The verified domain (may include 'www.' prefix).
            slug:   The site slug used to locate files under SITES_ROOT.

        Returns:
            {
                "success":    bool,   # Nginx vhost created and reloaded
                "ssl_issued": bool,   # SSL cert issued by certbot
                "error":      str | None,
            }
        """
        bare = _bare_domain(domain)
        server_names = f"{bare} www.{bare}"

        result: dict = {"success": False, "ssl_issued": False, "error": None}

        # 1. Write config ────────────────────────────────────────────────────
        config_path = Path(NGINX_AVAILABLE) / bare
        link_path = Path(NGINX_ENABLED) / bare

        config_content = _VHOST_TEMPLATE.format(
            bare_domain=bare,
            slug=slug,
            server_names=server_names,
            sites_root=SITES_ROOT,
        )

        try:
            config_path.write_text(config_content)
        except Exception as exc:
            result["error"] = f"Failed to write Nginx config: {exc}"
            logger.error(result["error"])
            return result

        # 2. Enable site ─────────────────────────────────────────────────────
        if not link_path.exists():
            try:
                link_path.symlink_to(config_path)
            except Exception as exc:
                result["error"] = f"Failed to enable site: {exc}"
                logger.error(result["error"])
                config_path.unlink(missing_ok=True)
                return result

        # 3. Test config ─────────────────────────────────────────────────────
        ok, output = await _run("nginx -t")
        if not ok:
            result["error"] = f"Nginx config test failed:\n{output}"
            logger.error(result["error"])
            # Roll back
            link_path.unlink(missing_ok=True)
            config_path.unlink(missing_ok=True)
            return result

        # 4. Reload Nginx ────────────────────────────────────────────────────
        await _run("systemctl reload nginx")
        result["success"] = True
        logger.info(f"[Provision] Nginx vhost created for {bare} → {slug}")

        # 5. SSL via certbot ─────────────────────────────────────────────────
        #    Requires the domain A record to already point to this server.
        #    If the record hasn't propagated yet certbot will fail gracefully.
        certbot_cmd = (
            f"certbot --nginx --non-interactive --agree-tos "
            f"--email {CERTBOT_EMAIL} -d {bare} -d www.{bare}"
        )
        ssl_ok, ssl_output = await _run(certbot_cmd)
        if ssl_ok:
            result["ssl_issued"] = True
            logger.info(f"[Provision] SSL certificate issued for {bare}")
        else:
            logger.warning(
                f"[Provision] SSL cert failed for {bare} "
                f"(DNS may not be pointing to this server yet):\n{ssl_output}"
            )

        return result

    @staticmethod
    async def deprovision(domain: str) -> None:
        """
        Remove the Nginx vhost for a domain that is being disconnected.

        Args:
            domain: The domain being disconnected (bare or www-prefixed).
        """
        bare = _bare_domain(domain)
        config_path = Path(NGINX_AVAILABLE) / bare
        link_path = Path(NGINX_ENABLED) / bare

        link_path.unlink(missing_ok=True)
        config_path.unlink(missing_ok=True)

        ok, output = await _run("nginx -t")
        if ok:
            await _run("systemctl reload nginx")
            logger.info(f"[Deprovision] Nginx vhost removed for {bare}")
        else:
            logger.error(f"[Deprovision] Nginx config error after removing {bare}:\n{output}")


# ── Private helpers ───────────────────────────────────────────────────────────

def _bare_domain(domain: str) -> str:
    """Return the root domain without a leading 'www.' prefix."""
    return domain.removeprefix("www.")


async def _run(cmd: str) -> tuple[bool, str]:
    """Run a shell command asynchronously. Returns (success, combined_output)."""
    proc = await asyncio.create_subprocess_shell(
        cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.STDOUT,
    )
    stdout, _ = await proc.communicate()
    output = stdout.decode(errors="replace") if stdout else ""
    return proc.returncode == 0, output
