"""
Nginx Provisioning Service

Automatically provisions (and deprovisions) Nginx virtual hosts + SSL certificates
for verified custom domains. All shell commands run via asyncio.subprocess so the
event loop is never blocked.

Design principle — we own the Nginx config, certbot only owns the certificate:
  Using `certbot certonly` (NOT `certbot --nginx`) means certbot only fetches the
  certificate files and never touches our Nginx configuration.  After the cert is
  obtained we write a *complete* HTTPS vhost template ourselves, so there is no risk
  of certbot appending SSL blocks to the wrong server block (e.g. the default site).

Flow triggered by DomainService.verify_domain() on success:
  1. Write HTTP-only vhost → enable symlink → nginx -t → reload
  2. Run `certbot certonly --nginx` (HTTP-01 challenge, cert files only)
  3. If cert obtained → overwrite vhost with full HTTPS template → reload
     If cert fails → site still serves over HTTP (non-fatal)

Flow triggered by DomainService.remove_domain():
  1. Remove symlink and config file
  2. nginx -t → reload
"""
import asyncio
import logging
import os
from pathlib import Path

logger = logging.getLogger(__name__)

# ── Constants ─────────────────────────────────────────────────────────────────

SITES_ROOT = "/var/www/sites"
NGINX_AVAILABLE = "/etc/nginx/sites-available"
NGINX_ENABLED = "/etc/nginx/sites-enabled"
LETSENCRYPT_LIVE = "/etc/letsencrypt/live"

# Read from environment so this works across deployments without code changes.
CERTBOT_EMAIL = os.getenv("CERTBOT_EMAIL", "admin@lavish.solutions")

# Public IP of this server — used both for Nginx provisioning checks and for
# the A-record validation step in DomainService. Keep in sync via env var.
SERVER_IP = os.getenv("SERVER_IP", "104.251.211.183")

# ── Nginx vhost templates ─────────────────────────────────────────────────────

# Phase 1: HTTP only — used while certbot obtains the certificate.
_HTTP_TEMPLATE = """\
# WebMagic custom domain: {bare_domain} → slug: {slug}
# Phase 1 (HTTP only) — will be replaced with HTTPS template after SSL is issued.
server {{
    listen 80;
    listen [::]:80;
    server_name {bare_domain} www.{bare_domain};

    root {sites_root}/{slug};
    index index.html;

    location / {{
        try_files $uri $uri/ /index.html;
    }}

    location ~* \\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|webp)$ {{
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}

    location ~* \\.html$ {{
        expires -1;
        add_header Cache-Control "no-store, no-cache, must-revalidate";
    }}

    location ~ /\\. {{ deny all; }}
}}
"""

# Phase 2: Full HTTPS — written after certbot succeeds.
_HTTPS_TEMPLATE = """\
# WebMagic custom domain: {bare_domain} → slug: {slug}
# Auto-generated by NginxProvisioningService — do not edit manually.
server {{
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name {bare_domain} www.{bare_domain};

    root {sites_root}/{slug};
    index index.html;

    ssl_certificate     {letsencrypt_live}/{bare_domain}/fullchain.pem;
    ssl_certificate_key {letsencrypt_live}/{bare_domain}/privkey.pem;
    include             /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;

    location / {{
        try_files $uri $uri/ /index.html;
    }}

    location ~* \\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|webp)$ {{
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}

    location ~* \\.html$ {{
        expires -1;
        add_header Cache-Control "no-store, no-cache, must-revalidate";
    }}

    location ~ /\\. {{ deny all; }}
}}

# HTTP → HTTPS redirect
server {{
    listen 80;
    listen [::]:80;
    server_name {bare_domain} www.{bare_domain};
    return 301 https://$host$request_uri;
}}
"""


# ── Service ───────────────────────────────────────────────────────────────────

class NginxProvisioningService:
    """Provisions / deprovisions Nginx vhosts and SSL certs for custom domains."""

    @staticmethod
    async def provision(domain: str, slug: str) -> dict:
        """
        Provision Nginx vhost + SSL for a verified domain.

        Args:
            domain: The verified domain (may include 'www.' prefix).
            slug:   The site slug used to locate files under SITES_ROOT.

        Returns:
            {
                "success":    bool,   # Nginx vhost created and reloaded
                "ssl_issued": bool,   # SSL cert issued by certbot
                "error":      str | None,
            }
        """
        bare = _bare_domain(domain)
        result: dict = {"success": False, "ssl_issued": False, "error": None}

        config_path = Path(NGINX_AVAILABLE) / bare
        link_path = Path(NGINX_ENABLED) / bare

        # ── Phase 1: HTTP vhost ──────────────────────────────────────────────
        http_config = _HTTP_TEMPLATE.format(
            bare_domain=bare,
            slug=slug,
            sites_root=SITES_ROOT,
        )
        try:
            config_path.write_text(http_config)
        except Exception as exc:
            result["error"] = f"Failed to write Nginx config: {exc}"
            logger.error(result["error"])
            return result

        if not link_path.exists():
            try:
                link_path.symlink_to(config_path)
            except Exception as exc:
                result["error"] = f"Failed to enable site: {exc}"
                logger.error(result["error"])
                config_path.unlink(missing_ok=True)
                return result

        ok, output = await _run("nginx -t")
        if not ok:
            result["error"] = f"Nginx config test failed:\n{output}"
            logger.error(result["error"])
            link_path.unlink(missing_ok=True)
            config_path.unlink(missing_ok=True)
            return result

        await _run("systemctl reload nginx")
        result["success"] = True
        logger.info(f"[Provision] HTTP vhost live for {bare} → {slug}")

        # ── Phase 2: SSL certificate (certonly — we keep full config control) ─
        # --certonly means certbot ONLY fetches the cert files; it does NOT
        # modify any Nginx configuration file.
        # --force-renewal clears any stale ACME authorization from a prior run.
        certbot_cmd = (
            f"certbot certonly --nginx --non-interactive --agree-tos "
            f"--force-renewal --cert-name {bare} "
            f"--email {CERTBOT_EMAIL} -d {bare} -d www.{bare}"
        )
        ssl_ok, ssl_output = await _run(certbot_cmd)

        if ssl_ok:
            # ── Phase 3: Overwrite vhost with complete HTTPS template ─────────
            https_config = _HTTPS_TEMPLATE.format(
                bare_domain=bare,
                slug=slug,
                sites_root=SITES_ROOT,
                letsencrypt_live=LETSENCRYPT_LIVE,
            )
            try:
                config_path.write_text(https_config)
                ok2, output2 = await _run("nginx -t")
                if ok2:
                    await _run("systemctl reload nginx")
                    result["ssl_issued"] = True
                    logger.info(f"[Provision] HTTPS vhost live for {bare}")
                else:
                    logger.error(f"[Provision] HTTPS config test failed for {bare}:\n{output2}")
            except Exception as exc:
                logger.error(f"[Provision] Failed to write HTTPS config for {bare}: {exc}")
        else:
            logger.warning(
                f"[Provision] SSL cert failed for {bare} — site stays on HTTP:\n{ssl_output}"
            )

        return result

    @staticmethod
    async def deprovision(domain: str) -> None:
        """
        Remove the Nginx vhost for a domain that is being disconnected.

        Args:
            domain: The domain being disconnected (bare or www-prefixed).
        """
        bare = _bare_domain(domain)
        config_path = Path(NGINX_AVAILABLE) / bare
        link_path = Path(NGINX_ENABLED) / bare

        link_path.unlink(missing_ok=True)
        config_path.unlink(missing_ok=True)

        ok, output = await _run("nginx -t")
        if ok:
            await _run("systemctl reload nginx")
            logger.info(f"[Deprovision] Nginx vhost removed for {bare}")
        else:
            logger.error(f"[Deprovision] Nginx config error after removing {bare}:\n{output}")


# ── Private helpers ───────────────────────────────────────────────────────────

def _bare_domain(domain: str) -> str:
    """Return the root domain without a leading 'www.' prefix."""
    return domain.removeprefix("www.")


async def _run(cmd: str) -> tuple[bool, str]:
    """Run a shell command asynchronously. Returns (success, combined_output)."""
    proc = await asyncio.create_subprocess_shell(
        cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.STDOUT,
    )
    stdout, _ = await proc.communicate()
    output = stdout.decode(errors="replace") if stdout else ""
    return proc.returncode == 0, output
