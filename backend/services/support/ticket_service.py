"""
Support Ticket Service

Handles ticket creation, AI categorization, message management, and status updates.
"""
import logging
import secrets
from typing import Dict, Any, List, Optional, Tuple
from uuid import UUID
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_
from sqlalchemy.orm import selectinload

from models.support_ticket import SupportTicket, TicketMessage, TicketTemplate
from models.site_models import CustomerUser, Site, SiteVersion, CustomerSiteOwnership
from core.exceptions import NotFoundError, ValidationError, ForbiddenError
from core.html_utils import strip_claim_bar, strip_claim_bar_css
from anthropic import AsyncAnthropic
from core.config import get_settings
from services.emails.email_service import get_email_service
from services.system_settings_service import SystemSettingsService

logger = logging.getLogger(__name__)
settings = get_settings()


class TicketService:
    """Service for managing support tickets."""

    @staticmethod
    async def _get_admin_email(db: AsyncSession) -> str:
        """
        Return the support notification email address.
        Checks the DB first (support_admin_email key, category notifications),
        falls back to SUPPORT_ADMIN_EMAIL from .env / config defaults.
        """
        db_value = await SystemSettingsService.get_setting(db, "support_admin_email")
        return db_value or settings.SUPPORT_ADMIN_EMAIL

    # Ticket categories
    CATEGORIES = [
        "billing",
        "technical_support",
        "site_edit",
        "question",
        "other"
    ]
    
    # Ticket statuses
    STATUSES = [
        "new",
        "in_progress",
        "waiting_customer",
        "waiting_ai",
        "resolved",
        "closed"
    ]
    
    # Priority levels
    PRIORITIES = [
        "low",
        "medium",
        "high",
        "urgent"
    ]
    
    @staticmethod
    def _generate_ticket_number() -> str:
        """Generate a unique ticket number."""
        timestamp = datetime.now(timezone.utc).strftime('%Y%m%d')
        random_part = secrets.token_hex(3).upper()
        return f"TKT-{timestamp}-{random_part}"
    
    @staticmethod
    async def create_ticket(
        db: AsyncSession,
        customer_user_id: UUID,
        subject: str,
        description: str,
        category: str,
        site_id: Optional[UUID] = None,
        changes: Optional[list] = None,
    ) -> SupportTicket:
        """
        Create a new support ticket.

        For site_edit tickets the `changes` parameter carries an ordered list of
        structured change dicts, each with `description` and optional `element_context`.
        These are stored in the `element_context` JSONB column and consumed by
        SiteEditProcessor Stage 2.

        Args:
            db: Database session
            customer_user_id: ID of the customer creating the ticket
            subject: Ticket subject (auto-generated by frontend for site_edit tickets)
            description: Combined plain-text summary
            category: Ticket category
            site_id: Optional site ID
            changes: Structured change list for site_edit tickets (max 3)

        Returns:
            Created SupportTicket instance
        """
        # Validate category
        if category not in TicketService.CATEGORIES:
            raise ValidationError(f"Invalid category. Must be one of: {', '.join(TicketService.CATEGORIES)}")
        
        # Verify customer exists
        customer_stmt = select(CustomerUser).where(CustomerUser.id == customer_user_id)
        customer_result = await db.execute(customer_stmt)
        customer = customer_result.scalar_one_or_none()
        
        if not customer:
            raise NotFoundError("Customer not found")
        
        # Verify site ownership if site_id provided
        if site_id:
            site_stmt = (
                select(Site)
                .join(CustomerSiteOwnership, CustomerSiteOwnership.site_id == Site.id)
                .where(
                    and_(
                        Site.id == site_id,
                        CustomerSiteOwnership.customer_user_id == customer_user_id,
                    )
                )
            )
            site_result = await db.execute(site_stmt)
            site = site_result.scalar_one_or_none()
            
            if not site:
                raise ForbiddenError("Site not found or not owned by customer")
        
        # Generate unique ticket number
        ticket_number = TicketService._generate_ticket_number()
        
        # Ensure uniqueness (unlikely collision, but check anyway)
        existing_stmt = select(SupportTicket).where(SupportTicket.ticket_number == ticket_number)
        existing_result = await db.execute(existing_stmt)
        if existing_result.scalar_one_or_none():
            # Regenerate if collision (extremely rare)
            ticket_number = TicketService._generate_ticket_number()
        
        # Create ticket
        ticket = SupportTicket(
            customer_user_id=customer_user_id,
            site_id=site_id,
            ticket_number=ticket_number,
            subject=subject,
            description=description,
            category=category,
            priority="medium",  # Default, will be updated by AI
            status="new",
            last_customer_message_at=datetime.now(timezone.utc),
            element_context=changes,  # List[TicketChange] dicts stored in JSONB
        )
        
        db.add(ticket)
        await db.flush()
        
        # Create initial message from customer
        initial_message = TicketMessage(
            ticket_id=ticket.id,
            customer_user_id=customer_user_id,
            message=description,
            message_type="customer",
            ai_generated=False
        )
        
        db.add(initial_message)
        await db.commit()

        # Reload ticket with messages so the response object is fully populated
        refreshed_stmt = (
            select(SupportTicket)
            .options(selectinload(SupportTicket.messages))
            .where(SupportTicket.id == ticket.id)
        )
        refreshed_result = await db.execute(refreshed_stmt)
        ticket = refreshed_result.scalar_one()

        # Email admin: new ticket notification (fire-and-forget)
        try:
            email_service = get_email_service()
            admin_email = await TicketService._get_admin_email(db)
            admin_link = f"{settings.FRONTEND_URL}/tickets/{ticket.id}"
            await email_service.send_new_ticket_admin_notification(
                admin_email=admin_email,
                ticket_number=ticket.ticket_number,
                customer_name=customer.full_name or customer.email,
                customer_email=customer.email,
                category=ticket.category,
                priority=ticket.priority,
                subject=ticket.subject,
                description=ticket.description,
                admin_link=admin_link,
            )
        except Exception as e:
            logger.error(f"Failed to send admin notification for ticket {ticket.ticket_number}: {e}")

        # Queue AI processing as a background Celery task — do NOT block the request
        try:
            from tasks.ticket_tasks import process_ticket_with_ai
            process_ticket_with_ai.delay(str(ticket.id))
            logger.info(f"Queued AI processing for ticket {ticket.ticket_number}")
        except Exception as e:
            logger.error(f"Failed to queue AI task for ticket {ticket.ticket_number}: {e}")

        return ticket
    
    @staticmethod
    async def _process_with_ai(
        db: AsyncSession,
        ticket: SupportTicket
    ) -> None:
        """
        Process ticket with AI for categorization, priority, and suggested response.
        
        Args:
            db: Database session
            ticket: Ticket to process
        """
        try:
            import json
            ai_client = AsyncAnthropic(api_key=settings.ANTHROPIC_API_KEY)
            
            # Build prompt for AI
            prompt = f"""You are a customer support AI assistant. Analyze the following support ticket and provide:
1. Category confidence scores (billing, technical_support, site_edit, question, other)
2. Priority level (low, medium, high, urgent)
3. A helpful, professional response

Ticket Information:
Subject: {ticket.subject}
Description: {ticket.description}
Current Category: {ticket.category}

Respond in JSON format:
{{
    "category_confidence": {{
        "billing": 0.0-1.0,
        "technical_support": 0.0-1.0,
        "site_edit": 0.0-1.0,
        "question": 0.0-1.0,
        "other": 0.0-1.0
    }},
    "suggested_category": "category_name",
    "priority": "low|medium|high|urgent",
    "priority_reasoning": "explanation",
    "suggested_response": "Your professional response here",
    "requires_human_review": true|false,
    "processing_notes": "Any important notes"
}}"""
            
            # Get AI response
            # Use streaming to avoid timeout limits on large max_tokens
            async with ai_client.messages.stream(
                model="claude-sonnet-4-5",
                max_tokens=64000,  # Max for Claude Sonnet 4.5
                temperature=0.3,
                system="You are a helpful customer support assistant.",
                messages=[
                    {"role": "user", "content": prompt}
                ]
            ) as stream:
                response_text = await stream.get_final_text()
            
            # Parse AI response
            try:
                ai_analysis = json.loads(response_text)
            except json.JSONDecodeError:
                logger.warning(f"Failed to parse AI response for ticket {ticket.ticket_number}")
                return
            
            # Update ticket with AI insights
            ticket.ai_processed = True
            ticket.ai_category_confidence = ai_analysis.get("category_confidence", {})
            ticket.ai_suggested_response = ai_analysis.get("suggested_response", "")
            ticket.ai_processing_notes = {
                "priority_reasoning": ai_analysis.get("priority_reasoning", ""),
                "requires_human_review": ai_analysis.get("requires_human_review", False),
                "processing_notes": ai_analysis.get("processing_notes", ""),
                "processed_at": datetime.now(timezone.utc).isoformat()
            }
            
            # Update priority if AI suggests different
            suggested_priority = ai_analysis.get("priority", "medium")
            if suggested_priority in TicketService.PRIORITIES:
                ticket.priority = suggested_priority
            
            # If AI suggests different category with high confidence
            suggested_category = ai_analysis.get("suggested_category")
            if suggested_category and suggested_category in TicketService.CATEGORIES:
                confidence = ai_analysis.get("category_confidence", {}).get(suggested_category, 0)
                if confidence > 0.8 and suggested_category != ticket.category:
                    logger.info(
                        f"AI suggests recategorizing ticket {ticket.ticket_number} "
                        f"from {ticket.category} to {suggested_category} (confidence: {confidence})"
                    )
                    ticket.category = suggested_category
            
            # Auto-respond for simple questions if confidence is high
            if (
                ticket.category == "question" and
                not ai_analysis.get("requires_human_review", False) and
                ai_analysis.get("category_confidence", {}).get("question", 0) > 0.9
            ):
                # Create AI response message
                ai_message = TicketMessage(
                    ticket_id=ticket.id,
                    message=ticket.ai_suggested_response,
                    message_type="ai",
                    ai_generated=True,
                    ai_model="claude-sonnet-4-5",
                    ai_confidence=ai_analysis.get("category_confidence", {})
                )
                db.add(ai_message)
                
                ticket.status = "waiting_customer"
                ticket.first_response_at = datetime.now(timezone.utc)
                ticket.last_staff_message_at = datetime.now(timezone.utc)
            else:
                # Mark as waiting for staff review
                ticket.status = "in_progress"
            
            await db.commit()

            # For site_edit tickets: run the 3-stage edit pipeline
            if ticket.category == "site_edit" and ticket.site_id:
                try:
                    from services.support.site_edit_processor import SiteEditProcessor
                    processor = SiteEditProcessor()
                    edit_result = await processor.process(db=db, ticket=ticket)

                    # Merge edit pipeline result into ai_processing_notes
                    current_notes = ticket.ai_processing_notes or {}
                    current_notes.update(edit_result)
                    ticket.ai_processing_notes = current_notes
                    await db.commit()

                    logger.info(
                        f"[SiteEditProcessor] Completed for ticket {ticket.ticket_number}: "
                        f"summary={edit_result.get('edit_summary')}, "
                        f"preview_id={edit_result.get('preview_version_id')}"
                    )
                except Exception as edit_err:
                    logger.error(
                        f"[SiteEditProcessor] Failed for ticket {ticket.ticket_number}: {edit_err}"
                    )
            
        except Exception as e:
            logger.error(f"Error in AI processing for ticket {ticket.ticket_number}: {e}")
            # Don't raise - ticket creation should succeed even if AI fails
    
    @staticmethod
    async def add_message(
        db: AsyncSession,
        ticket_id: UUID,
        message: str,
        author_id: UUID,
        author_type: str,  # 'customer' or 'staff'
        internal_only: bool = False
    ) -> TicketMessage:
        """
        Add a message to a ticket.
        
        Args:
            db: Database session
            ticket_id: ID of the ticket
            message: Message content
            author_id: ID of the author (customer_user_id or admin_user_id)
            author_type: Type of author ('customer' or 'staff')
            internal_only: Whether message is internal only (staff notes)
            
        Returns:
            Created TicketMessage instance
        """
        # Get ticket
        stmt = select(SupportTicket).where(SupportTicket.id == ticket_id)
        result = await db.execute(stmt)
        ticket = result.scalar_one_or_none()
        
        if not ticket:
            raise NotFoundError("Ticket not found")
        
        # Create message
        ticket_message = TicketMessage(
            ticket_id=ticket_id,
            message=message,
            message_type=author_type,
            internal_only=internal_only,
            ai_generated=False
        )
        
        if author_type == "customer":
            ticket_message.customer_user_id = author_id
            ticket.last_customer_message_at = datetime.now(timezone.utc)
            
            # If customer responds, move from resolved/waiting_ai to in_progress
            if ticket.status in ["resolved", "waiting_ai", "waiting_customer"]:
                ticket.status = "in_progress"
        elif author_type == "staff":
            ticket_message.admin_user_id = author_id
            ticket.last_staff_message_at = datetime.now(timezone.utc)
            
            # First staff response
            if not ticket.first_response_at:
                ticket.first_response_at = datetime.now(timezone.utc)
            
            # If staff responds, move to waiting_customer
            if ticket.status in ["new", "in_progress"]:
                ticket.status = "waiting_customer"
        
        db.add(ticket_message)
        await db.commit()
        await db.refresh(ticket_message)
        
        # Email notifications (failures must not break the reply)
        try:
            email_service = get_email_service()
            admin_email = await TicketService._get_admin_email(db)
            portal_link = f"{settings.FRONTEND_URL}/customer/tickets/{ticket.id}"
            admin_link = f"{settings.FRONTEND_URL}/tickets/{ticket.id}"

            if author_type in ("staff", "ai") and not internal_only:
                # Notify customer that staff/AI replied
                customer_stmt = select(CustomerUser).where(
                    CustomerUser.id == ticket.customer_user_id
                )
                customer_result = await db.execute(customer_stmt)
                ticket_customer = customer_result.scalar_one_or_none()
                if ticket_customer:
                    await email_service.send_ticket_reply_to_customer(
                        customer_email=ticket_customer.email,
                        customer_name=ticket_customer.full_name or ticket_customer.email,
                        ticket_number=ticket.ticket_number,
                        subject=ticket.subject,
                        reply_message=message,
                        portal_link=portal_link,
                        is_ai_reply=(author_type == "ai"),
                    )
            elif author_type == "customer":
                # Notify admin that customer replied
                customer_stmt = select(CustomerUser).where(
                    CustomerUser.id == author_id
                )
                customer_result = await db.execute(customer_stmt)
                replying_customer = customer_result.scalar_one_or_none()
                customer_name = replying_customer.full_name or replying_customer.email if replying_customer else "Customer"
                customer_email_addr = replying_customer.email if replying_customer else ""
                await email_service.send_customer_reply_admin_notification(
                    admin_email=admin_email,
                    ticket_number=ticket.ticket_number,
                    customer_name=customer_name,
                    customer_email=customer_email_addr,
                    subject=ticket.subject,
                    reply_message=message,
                    admin_link=admin_link,
                )
        except Exception as e:
            logger.error(f"Failed to send reply email notification for ticket {ticket_id}: {e}")

        return ticket_message
    
    @staticmethod
    async def get_ticket_by_id(
        db: AsyncSession,
        ticket_id: UUID,
        customer_user_id: Optional[UUID] = None
    ) -> SupportTicket:
        """
        Get ticket by ID with messages.
        
        Args:
            db: Database session
            ticket_id: Ticket ID
            customer_user_id: Optional customer ID for ownership verification
            
        Returns:
            SupportTicket instance with messages
        """
        stmt = (
            select(SupportTicket)
            .where(SupportTicket.id == ticket_id)
            .options(
                selectinload(SupportTicket.messages),
                selectinload(SupportTicket.customer_user),
                selectinload(SupportTicket.site),
            )
        )

        # Add customer filter if provided
        if customer_user_id:
            stmt = stmt.where(SupportTicket.customer_user_id == customer_user_id)

        result = await db.execute(stmt)
        ticket = result.scalar_one_or_none()

        if not ticket:
            raise NotFoundError("Ticket not found")

        return ticket
    
    @staticmethod
    async def list_customer_tickets(
        db: AsyncSession,
        customer_user_id: UUID,
        status: Optional[str] = None,
        category: Optional[str] = None,
        limit: int = 50,
        offset: int = 0
    ) -> Tuple[List[SupportTicket], int]:
        """
        List tickets for a customer.
        
        Args:
            db: Database session
            customer_user_id: Customer user ID
            status: Optional status filter
            category: Optional category filter
            limit: Number of results to return
            offset: Offset for pagination
            
        Returns:
            Tuple of (list of tickets, total count)
        """
        # Build base query (without options for count)
        base_stmt = select(SupportTicket).where(
            SupportTicket.customer_user_id == customer_user_id
        )

        if status:
            base_stmt = base_stmt.where(SupportTicket.status == status)
        if category:
            base_stmt = base_stmt.where(SupportTicket.category == category)

        # Count total
        count_stmt = select(func.count()).select_from(base_stmt.subquery())
        count_result = await db.execute(count_stmt)
        total = count_result.scalar() or 0

        # Get tickets with messages eagerly loaded to avoid async lazy-load errors
        fetch_stmt = (
            base_stmt
            .options(selectinload(SupportTicket.messages))
            .order_by(SupportTicket.created_at.desc())
            .limit(limit)
            .offset(offset)
        )
        result = await db.execute(fetch_stmt)
        tickets = result.scalars().all()

        return list(tickets), total
    
    @staticmethod
    async def update_ticket_status(
        db: AsyncSession,
        ticket_id: UUID,
        new_status: str,
        customer_user_id: Optional[UUID] = None
    ) -> SupportTicket:
        """
        Update ticket status.
        
        Args:
            db: Database session
            ticket_id: Ticket ID
            new_status: New status
            customer_user_id: Optional customer ID for ownership verification
            
        Returns:
            Updated SupportTicket instance
        """
        if new_status not in TicketService.STATUSES:
            raise ValidationError(f"Invalid status. Must be one of: {', '.join(TicketService.STATUSES)}")
        
        # Get ticket
        stmt = select(SupportTicket).where(SupportTicket.id == ticket_id)
        if customer_user_id:
            stmt = stmt.where(SupportTicket.customer_user_id == customer_user_id)

        result = await db.execute(stmt)
        ticket = result.scalar_one_or_none()

        if not ticket:
            raise NotFoundError("Ticket not found")

        old_status = ticket.status
        ticket.status = new_status

        # Update timestamps based on status
        now = datetime.now(timezone.utc)
        if new_status == "resolved" and old_status != "resolved":
            ticket.resolved_at = now
        elif new_status == "closed" and old_status != "closed":
            ticket.closed_at = now

        await db.commit()

        # Reload with messages to satisfy response serialization
        reloaded = await db.execute(
            select(SupportTicket)
            .options(selectinload(SupportTicket.messages))
            .where(SupportTicket.id == ticket.id)
        )
        return reloaded.scalar_one()
    
    @staticmethod
    async def get_ticket_stats(
        db: AsyncSession,
        customer_user_id: UUID
    ) -> Dict[str, Any]:
        """
        Get ticket statistics for a customer.
        
        Args:
            db: Database session
            customer_user_id: Customer user ID
            
        Returns:
            Dictionary with ticket statistics
        """
        # Get counts by status
        status_stmt = select(
            SupportTicket.status,
            func.count(SupportTicket.id)
        ).where(
            SupportTicket.customer_user_id == customer_user_id
        ).group_by(SupportTicket.status)
        
        status_result = await db.execute(status_stmt)
        status_counts = dict(status_result.fetchall())
        
        # Get counts by category
        category_stmt = select(
            SupportTicket.category,
            func.count(SupportTicket.id)
        ).where(
            SupportTicket.customer_user_id == customer_user_id
        ).group_by(SupportTicket.category)
        
        category_result = await db.execute(category_stmt)
        category_counts = dict(category_result.fetchall())
        
        # Get total count
        total_stmt = select(func.count(SupportTicket.id)).where(
            SupportTicket.customer_user_id == customer_user_id
        )
        total_result = await db.execute(total_stmt)
        total = total_result.scalar() or 0
        
        return {
            "total": total,
            "by_status": status_counts,
            "by_category": category_counts,
            "open": status_counts.get("new", 0) + status_counts.get("in_progress", 0),
            "waiting": status_counts.get("waiting_customer", 0) + status_counts.get("waiting_ai", 0),
            "resolved": status_counts.get("resolved", 0),
            "closed": status_counts.get("closed", 0)
        }

    @staticmethod
    async def list_all_tickets(
        db: AsyncSession,
        status: Optional[str] = None,
        category: Optional[str] = None,
        priority: Optional[str] = None,
        site_slug: Optional[str] = None,
        search: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> Tuple[List[SupportTicket], int]:
        """
        Admin-only: list all tickets across all customers.
        Supports filtering by status, category, priority, site_slug, and text search.
        """
        base_stmt = select(SupportTicket)

        if status:
            base_stmt = base_stmt.where(SupportTicket.status == status)
        if category:
            base_stmt = base_stmt.where(SupportTicket.category == category)
        if priority:
            base_stmt = base_stmt.where(SupportTicket.priority == priority)
        if site_slug:
            base_stmt = base_stmt.join(Site, SupportTicket.site_id == Site.id).where(Site.slug == site_slug)
        if search:
            search_term = f"%{search}%"
            base_stmt = base_stmt.where(
                or_(
                    SupportTicket.subject.ilike(search_term),
                    SupportTicket.ticket_number.ilike(search_term),
                )
            )

        count_stmt = select(func.count()).select_from(base_stmt.subquery())
        count_result = await db.execute(count_stmt)
        total = count_result.scalar() or 0

        fetch_stmt = (
            base_stmt
            .options(
                selectinload(SupportTicket.customer_user),
                selectinload(SupportTicket.site),
                selectinload(SupportTicket.messages),
            )
            .order_by(SupportTicket.created_at.desc())
            .limit(limit)
            .offset(offset)
        )
        result = await db.execute(fetch_stmt)
        tickets = result.scalars().all()

        return list(tickets), total

    @staticmethod
    async def apply_site_edit(
        db: AsyncSession,
        ticket_id: UUID,
        admin_user_id: UUID,
    ) -> SupportTicket:
        """
        Apply the AI-proposed site edit for a site_edit ticket.
        1. Reads preview_version_id from ai_processing_notes
        2. Promotes that SiteVersion to is_current=True
        3. Writes files to disk via SiteService.deploy_site()
        4. Posts a staff message and resolves the ticket
        5. Emails the customer
        """
        from services.site_service import SiteService as FileSiteService

        stmt = (
            select(SupportTicket)
            .where(SupportTicket.id == ticket_id)
            .options(
                selectinload(SupportTicket.customer_user),
                selectinload(SupportTicket.site),
            )
        )
        result = await db.execute(stmt)
        ticket = result.scalar_one_or_none()

        if not ticket:
            raise NotFoundError("Ticket not found")
        if ticket.category != "site_edit":
            raise ValidationError("Only site_edit tickets can have edits applied")

        notes = ticket.ai_processing_notes or {}
        preview_version_id = notes.get("preview_version_id")
        if not preview_version_id:
            raise ValidationError("No preview version available for this ticket")

        # Load preview version
        version_stmt = select(SiteVersion).where(SiteVersion.id == preview_version_id)
        version_result = await db.execute(version_stmt)
        preview_version = version_result.scalar_one_or_none()

        if not preview_version:
            raise NotFoundError("Preview version not found")

        # Unset current version on existing versions for this site
        unset_stmt = (
            select(SiteVersion)
            .where(SiteVersion.site_id == preview_version.site_id)
            .where(SiteVersion.is_current == True)  # noqa: E712
        )
        unset_result = await db.execute(unset_stmt)
        for old_version in unset_result.scalars().all():
            old_version.is_current = False

        # Promote preview version
        preview_version.is_current = True
        preview_version.is_preview = False

        # Update site's current_version_id
        if ticket.site:
            ticket.site.current_version_id = preview_version.id

        await db.flush()

        # Deploy to disk — strip claim bar since this is an owned/purchased site
        try:
            site_slug = ticket.site.slug if ticket.site else None
            if site_slug:
                file_service = FileSiteService()
                deploy_html = strip_claim_bar(preview_version.html_content or "")
                deploy_css = strip_claim_bar_css(preview_version.css_content or "")
                file_service.deploy_site(
                    slug=site_slug,
                    html_content=deploy_html,
                    css_content=deploy_css,
                    js_content=preview_version.js_content,
                    overwrite=True,
                )
        except Exception as deploy_err:
            logger.error(f"Failed to deploy site for ticket {ticket_id}: {deploy_err}")

        # Post staff confirmation message
        edit_summary = notes.get("edit_summary", "Your requested changes have been applied.")
        confirmation = TicketMessage(
            ticket_id=ticket_id,
            admin_user_id=admin_user_id,
            message=(
                f"✅ Your website has been updated! {edit_summary}\n\n"
                "The changes are now live on your website. "
                "Please check it and let us know if you need any further adjustments."
            ),
            message_type="staff",
            ai_generated=False,
        )
        db.add(confirmation)

        # Resolve ticket
        ticket.status = "resolved"
        ticket.resolved_at = datetime.now(timezone.utc)
        ticket.last_staff_message_at = datetime.now(timezone.utc)
        if not ticket.first_response_at:
            ticket.first_response_at = datetime.now(timezone.utc)

        await db.commit()

        # Reload with messages to satisfy response serialization
        reloaded = await db.execute(
            select(SupportTicket)
            .options(
                selectinload(SupportTicket.customer_user),
                selectinload(SupportTicket.site),
                selectinload(SupportTicket.messages),
            )
            .where(SupportTicket.id == ticket_id)
        )
        ticket = reloaded.scalar_one()

        # Email customer
        try:
            email_service = get_email_service()
            if ticket.customer_user:
                portal_link = f"{settings.FRONTEND_URL}/customer/tickets/{ticket_id}"
                await email_service.send_ticket_reply_to_customer(
                    customer_email=ticket.customer_user.email,
                    customer_name=ticket.customer_user.full_name or ticket.customer_user.email,
                    ticket_number=ticket.ticket_number,
                    subject=ticket.subject,
                    reply_message=confirmation.message,
                    portal_link=portal_link,
                    is_ai_reply=False,
                )
        except Exception as e:
            logger.error(f"Failed to send apply-edit confirmation email: {e}")

        return ticket

